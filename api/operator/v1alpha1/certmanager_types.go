package v1alpha1

import (
	apiv1 "github.com/openshift/api/operator/v1"
	corev1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CertManagerSpec defines the desired state of CertManager
type CertManagerSpec struct {
	apiv1.OperatorSpec `json:",inline"`

	// ControllerConfig specifies further customization options for the controller's deployment spec.
	//
	// Possible customizations include the following,
	//
	// For OverrideArgs,
	// This field appends values to .spec.template.spec.containers[...].args. The container
	// that will be selected will be based on image present on the spec. Possible values are,
	// Eg:
	//   - "--acme-http01-solver-nameservers="8.8.8.8:53,1.1.1.1:53"
	//   - "--dns01-recursive-nameservers=8.8.8.8:53,1.1.1.1:53"
	//   - "--dns01-recursive-nameservers-only"
	//
	// For OverrideEnvs,
	// This field appends values to .spec.template.spec.containers[...].env. The container
	// that will be selected will be based on image present on the spec. Possible values are,
	// Eg:
	//   - "HTTP_PROXY": "http://proxy:8080"
	//
	// +kubebuilder:validation:Optional
	// +optional
	ControllerConfig *DeploymentConfig `json:"controllerConfig,omitempty"`

	// WebhookConfig specifies further customization options for the webhook's deployment spec.
	//
	// Possible customizations include the following,
	//
	// For OverrideArgs,
	// --config string                                Path to a file containing a WebhookConfiguration object used to configure the webhook
	// --dynamic-serving-ca-secret-name string        name of the secret used to store the CA that signs serving certificates certificates
	// --dynamic-serving-ca-secret-namespace string   namespace of the secret used to store the CA that signs serving certificates
	// --dynamic-serving-dns-names strings            DNS names that should be present on certificates generated by the dynamic serving CA
	// --v Level                                      number for the log level verbosity
	//
	// +kubebuilder:validation:Optional
	// +optional
	WebhookConfig *DeploymentConfig `json:"webhookConfig,omitempty"`

	// CAInjectorConfig specifies further customization options for the cainjector's deployment spec.
	//
	// Possible customizations include the following,
	//
	// For OverrideArgs,
	// --namespace string                          If set, this limits the scope of cainjector to a single namespace. If set, cainjector
	//                                             will not update resources with certificates outside of the configured namespace.
	// --v Level                                   number for the log level verbosity
	//
	// +kubebuilder:validation:Optional
	// +optional
	CAInjectorConfig *DeploymentConfig `json:"cainjectorConfig,omitempty"`

	// DefaultNetworkPolicy enables the default network policy for cert-manager components.
	// When set to "true", the operator will create default network policies to secure
	// communication between cert-manager controller, webhook, and cainjector components.
	// When set to "false" or empty, no default network policies are created.
	// Valid values are: "true", "false", or empty (default: false).
	//
	// This field is immutable once set to "true" for security reasons. Network policies
	// cannot be disabled once enabled to prevent accidental security degradation.
	// Users should carefully plan their network policy requirements before enabling this field.
	//
	// +kubebuilder:validation:Optional
	// +kubebuilder:validation:Enum:="true";"false";""
	// +kubebuilder:validation:XValidation:rule="oldSelf != 'true' || self == 'true'",message="defaultNetworkPolicy cannot be changed from 'true' to 'false' once set"
	// +optional
	DefaultNetworkPolicy string `json:"defaultNetworkPolicy,omitempty"`

	// NetworkPolicies specifies the egress network policy configuration to be applied to cert-manager
	// pods/operands when DefaultNetworkPolicy is "true". By default, enabling network policies
	// creates a deny-all policy that blocks all outgoing traffic from cert-manager components.
	// Ingress rules are automatically handled by the operator based on the current running ports.
	// Use this field to provide the necessary egress policy rules that allow required outbound traffic
	// for cert-manager to function properly (e.g., API server communication, external issuer access, etc.).
	//
	// Each NetworkPolicy in this slice will be created as a separate Kubernetes NetworkPolicy
	// resource. Multiple policies can be defined to organize egress rules logically (e.g., separate
	// policies for different types of outbound traffic or different security zones).
	//
	// This field is only effective when DefaultNetworkPolicy is set to "true".
	// If DefaultNetworkPolicy is "true" but this field is not provided, cert-manager
	// components will be isolated with deny-all egress policies.
	//
	// This field is immutable once DefaultNetworkPolicy is set to "true" for security reasons.
	//
	// +kubebuilder:validation:Optional
	// +kubebuilder:validation:XValidation:rule="oldSelf.all(op, self.exists(p, p.name == op.name && p.componentName == op.componentName))",message="name and componentName fields in networkPolicies are immutable"
	// +kubebuilder:validation:MinItems:=0
	// +kubebuilder:validation:MaxItems:=50
	// +kubebuilder:validation:Optional
	// +listType=map
	// +listMapKey=name
	// +listMapKey=componentName
	// +optional
	NetworkPolicies []NetworkPolicy `json:"networkPolicies,omitempty"`
}

// DeploymentConfig defines the schema for
// overriding deployment of cert-manager operands,
// namely the controller, webhook and cainjector.
type DeploymentConfig struct {

	// +kubebuilder:validation:Optional
	// +optional
	OverrideArgs []string `json:"overrideArgs,omitempty"`

	// +kubebuilder:validation:Optional
	// +optional
	OverrideEnv []corev1.EnvVar `json:"overrideEnv,omitempty"`

	// +kubebuilder:validation:Optional
	// +optional
	OverrideLabels map[string]string `json:"overrideLabels,omitempty"`

	// +kubebuilder:validation:Optional
	// +optional
	OverrideResources CertManagerResourceRequirements `json:"overrideResources,omitempty"`

	// OverrideReplicas defines the number of replicas for the operand deployment.
	// If not specified, the default replicas from the deployment manifest will be used.
	// +kubebuilder:validation:Optional
	// +kubebuilder:validation:Minimum=1
	// +optional
	OverrideReplicas *int32 `json:"overrideReplicas,omitempty"`

	// +kubebuilder:validation:Optional
	// +optional
	OverrideScheduling CertManagerScheduling `json:"overrideScheduling,omitempty"`
}

// CertManagerResourceRequirements describes the compute resource requirements for the cert-manager operands,
// namely the controller, webhook and cainjector.
type CertManagerResourceRequirements struct {
	// Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// +optional
	Limits corev1.ResourceList `json:"limits,omitempty" protobuf:"bytes,1,rep,name=limits,casttype=ResourceList,castkey=ResourceName"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// +optional
	Requests corev1.ResourceList `json:"requests,omitempty" protobuf:"bytes,2,rep,name=requests,casttype=ResourceList,castkey=ResourceName"`
}

// CertManagerScheduling describes the scheduling configurations for the cert-manager operands,
// namely the controller, webhook and cainjector.
type CertManagerScheduling struct {
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	// +optional
	// +mapType=atomic
	NodeSelector map[string]string `json:"nodeSelector,omitempty" protobuf:"bytes,7,rep,name=nodeSelector"`

	// Tolerations are attached to the pod to tolerate any taint that matches the
	// taint's key, value and effect using the toleration's matching operator.
	// More info: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	// +optional
	// +listType=atomic
	Tolerations []corev1.Toleration `json:"tolerations,omitempty" protobuf:"bytes,22,opt,name=tolerations"`
}

// CertManagerStatus defines the observed state of CertManager
type CertManagerStatus struct {
	apiv1.OperatorStatus `json:",inline"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
//+kubebuilder:object:root=true
//+kubebuilder:subresource:status
//+kubebuilder:resource:scope=Cluster

// CertManager is the Schema for the certmanagers API
// +operator-sdk:csv:customresourcedefinitions:displayName="CertManager"
type CertManager struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	// +kubebuilder:validation:Required
	// +required
	Spec CertManagerSpec `json:"spec,omitempty"`
	// +optional
	Status CertManagerStatus `json:"status,omitempty"`
}

type UnsupportedConfigOverrides struct {
	Controller UnsupportedConfigOverridesForCertManagerController `json:"controller,omitempty"`
	Webhook    UnsupportedConfigOverridesForCertManagerWebhook    `json:"webhook,omitempty"`
	CAInjector UnsupportedConfigOverridesForCertManagerCAInjector `json:"cainjector,omitempty"`
}

type UnsupportedConfigOverridesForCertManagerController struct {
	Args []string `json:"args,omitempty"`
}

type UnsupportedConfigOverridesForCertManagerWebhook struct {
	Args []string `json:"args,omitempty"`
}

type UnsupportedConfigOverridesForCertManagerCAInjector struct {
	Args []string `json:"args,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
//+kubebuilder:object:root=true

// CertManagerList contains a list of CertManager
type CertManagerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata"`

	Items []CertManager `json:"items"`
}

// ComponentName represents the different cert-manager components that can have network policies applied.
type ComponentName string

const (
	// CAInjector represents the cert-manager CA injector component
	CAInjector ComponentName = "CAInjector"

	// CoreController represents the cert-manager core controller component
	CoreController ComponentName = "CoreController"

	// Webhook represents the cert-manager webhook component
	Webhook ComponentName = "Webhook"
)

// NetworkPolicy represents a custom network policy configuration for operator-managed components.
// It includes a name for identification and the network policy rules to be enforced.
type NetworkPolicy struct {
	// Name is a unique identifier for this network policy configuration.
	// This name will be used as part of the generated NetworkPolicy resource name.
	// +kubebuilder:validation:MinLength:=1
	// +kubebuilder:validation:MaxLength:=253
	// +kubebuilder:validation:Required
	// +required
	Name string `json:"name"`

	// ComponentName represents the different cert-manager components that can have network policies applied.
	// +kubebuilder:validation:Enum=CAInjector;CoreController;Webhook
	// +kubebuilder:validation:Required
	// +required
	ComponentName ComponentName `json:"componentName"`

	// egress is a list of egress rules to be applied to the selected pods. Outgoing traffic
	// is allowed if there are no NetworkPolicies selecting the pod (and cluster policy
	// otherwise allows the traffic), OR if the traffic matches at least one egress rule
	// across all of the NetworkPolicy objects whose podSelector matches the pod. If
	// this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
	// solely to ensure that the pods it selects are isolated by default).
	// The operator will automatically handle ingress rules based on the current running ports.
	// +optional
	// +listType=atomic
	Egress []networkingv1.NetworkPolicyEgressRule `json:"egress,omitempty" protobuf:"bytes,3,rep,name=egress"`
}

func init() {
	SchemeBuilder.Register(&CertManager{}, &CertManagerList{})
}
